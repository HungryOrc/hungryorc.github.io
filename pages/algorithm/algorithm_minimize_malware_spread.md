---
title: "Minimize Malware Spread"
tags: [algorithm, union_find]
keywords:
summary:
sidebar: mydoc_sidebar
permalink: algorithm_minimize_malware_spread.html
folder: algorithm
toc: false
---

## Description: Hard
In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.

Note:
* 1 < graph.length = graph[0].length <= 300
* 0 <= graph[i][j] == graph[j][i] <= 1
* graph[i][i] = 1
* 1 <= initial.length < graph.length
* 0 <= initial[i] < graph.length

### Example
* Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
  * Output: 0, 因为index 0 更小，比起1来说
* Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
  * Output: 0
* Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
  * Output: 1

## Solution： 我的Union Find 的方法，速度前50%，以后可以再看看如何优化

### Complexity
* Time: O(n) <==== ？？？？
* Space: O(n) <==== ？？？？

### Java
```java
public class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // ignore sanity checks
        
        int n = graph.length;
        ArrayUnionFind uf = new ArrayUnionFind(n, initial);
        
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 0) continue;
                if (!uf.find(i, j)) {
                    uf.union(i, j);
                }
            }
        }
        
        // 把各个Group object 搞起来，并按照题目的最终目的来排序
        List<Group> allFinalGroups = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            int curGroupSize = uf.groupSizes[i];
            
            if (curGroupSize > 0) {
                Set<Integer> curGroupInitiallyInfectedNodes = 
                    uf.initiallyInfectedNodesPerGroup[i];
                List<Integer> infectedNodes = 
                    new ArrayList<>(curGroupInitiallyInfectedNodes);
                
                Group group = new Group(curGroupSize, infectedNodes);
                allFinalGroups.add(group);
            }
        }
        
        Collections.sort(allFinalGroups);
        
        for (Group group : allFinalGroups) {
            // 如果一个group里没有任何 初始感染的点，我们是不需要这个group的
            if (group.initiallyInfectedNodes.size() == 0) {
                continue;
            }
            
            // 我们要找的是：拥有且仅拥有 一个初始感叹点 的group
            if (group.initiallyInfectedNodes.size() == 1) {
                // 我们只返回这些初始感染点里，index最小的一个
                return group.initiallyInfectedNodes.get(0);
            }
            
            // 还是没有的话，就返回遇到的第一个size比1大的group的最小的感染点
            if (group.initiallyInfectedNodes.size() > 1) {
                return group.initiallyInfectedNodes.get(0);
            }
        }
        return -1;
    }
}

class ArrayUnionFind {
    int[] groupIDs;
    int[] groupSizes;
    Set<Integer> allInitiallyInfectedNodes;
    Set<Integer>[] initiallyInfectedNodesPerGroup;
    
    public ArrayUnionFind(int n, int[] initiallyInfectedNodes) {
        this.groupIDs = new int[n];
        for (int i = 0; i < n; i++) groupIDs[i] = i;
        
        this.groupSizes = new int[n];
        for (int i = 0; i < n; i++) groupSizes[i] = 1;
        
        this.allInitiallyInfectedNodes = new HashSet<>();
        for (int node : initiallyInfectedNodes) {
            this.allInitiallyInfectedNodes.add(node);
        }
        
        this.initiallyInfectedNodesPerGroup = new HashSet[n];
        // 初始化各个group里的 记录初始感染点的set
        for (int i = 0; i < n; i++) {
            initiallyInfectedNodesPerGroup[i] = new HashSet<>();
            if (allInitiallyInfectedNodes.contains(i)) {
                initiallyInfectedNodesPerGroup[i].add(i);
            }
        }
    }
    
    public int getGroupID(int i) {
        int cur = i;
        int groupID = i;
        
        while (groupIDs[cur] != cur) {
            cur = groupIDs[cur];
        }
        groupID = cur;
        
        cur = i;
        while (groupIDs[cur] != cur) {
            int parentID = groupIDs[cur];
            groupIDs[cur] = groupID;
            cur = parentID;
        }
        
        return groupID; 
    }
    
    public boolean find(int i, int j) {
        return getGroupID(i) == getGroupID(j);
    }
    
    public void union(int i, int j) {
        if (i == j) return;
        
        int groupID1 = getGroupID(i);
        int groupID2 = getGroupID(j);
        
        if (groupID1 == groupID2) return;
        
        // 把group1 并到 group2 里去
        // 第一步，把group1的root的parent设为group2的root的parent
        groupIDs[groupID1] = groupID2;
        // 第二步，把group2的size更新一下，group1的size重置为0
        groupSizes[groupID2] += groupSizes[groupID1];
        groupSizes[groupID1] = 0;
        // 第三步，把group2里的初始感染点的名单增加一下，把group1里的名单清空
        initiallyInfectedNodesPerGroup[groupID2].addAll(
            initiallyInfectedNodesPerGroup[groupID1]);
        initiallyInfectedNodesPerGroup[groupID1].clear();
    }
}

class Group implements Comparable<Group> {
    int size;
    List<Integer> initiallyInfectedNodes;
    
    public Group(int size, List<Integer> initiallyInfectedNodes) {
        this.size = size;
        this.initiallyInfectedNodes = initiallyInfectedNodes;
        Collections.sort(initiallyInfectedNodes); // 里面的感染的nodes按indexes从小到大排好
    }
    
    // 整个group里没有 initially infected nodes的group会排在最前面，
    // 只有1个 initially infected nodes的groups会排在后面，
    // 然后是有2个、3个、4个 initially infected nodes的groups......
    // 如果两个group的 initially infected nodes的个数相同，则size大的排在前面。
    // 如果2个group的size也还是相同，则初始感染点
    @Override
    public int compareTo(Group g2) {
        int result = Integer.compare(this.initiallyInfectedNodes.size(), 
                                     g2.initiallyInfectedNodes.size());
        if (result != 0) return result;
        // 如果2个group里都没有 初始的感染点，则返回0
        if (result == 0 && this.initiallyInfectedNodes.size() == 0) return 0;
        
        result = Integer.compare(this.size, g2.size) * (-1); // 乘以-1是因为大的要在前面
        if (result != 0) return result;
        if (result == 0 && this.size == 0) return 0; // 如果2个group都是空的，则返回0
        
        // 返回2个group里，（最小index的）初始感染点 的index较小的那个
        return Integer.compare(this.initiallyInfectedNodes.get(0),
                               g2.initiallyInfectedNodes.get(0));
    }
}
```

## Reference
* [Minimize Malware Spread [LeetCode]](https://leetcode.com/problems/minimize-malware-spread/description/)

{% include links.html %}
