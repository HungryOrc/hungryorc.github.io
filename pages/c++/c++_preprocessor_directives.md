---
title: "Preprocessor Directives in C++"
tags: [c++]
keywords: include
summary:
sidebar: mydoc_sidebar
permalink: c++_preprocessor_directives.html
folder: c++
toc: false
---

"Preprocessor Directives" are lines preceded by `#`. These lines are not program statements, but directives for the "Preprocessor". The Preprocessor examines the code before actual compilation of code begins and resolves all these directives before any code is actually generated by regular statements.

These Preprocessor Directives extend only across a single line, as soon as a newline character is found, the Preprocessor  Directive is ended. No `;` is expected at the end of a Preprocessor Directive. The only way a Preprocessor Directive can extend through more than one line is by preceding the newline character at the end of the line by a backslash `\`.

## Macro Definitions (#define, #undef)

### Preprocessor Macros

To define Preprocessor Macros we can use `#define`, like: `#define identifier replacement`. When the Preprocessor encounters this directive, it replaces any occurence of `identifier` in the rest of the code by `replacement`. `replacement` can be an expression, a statement, a block or simply anything. The Preprocessor does not implement any syntax checking. For example:
```c++
#define TABLE_SIZE 100
int table1[TABLE_SIZE];
int table2@TABLE_SIZE@;
```
The code above will be equivalent to:
```c++
int table1[100];
int table2@100@;
```

Defined macros are not affected by block structure. A macro lasts until it is undefined with the `#undef` preprocessor directive:
```c++
#define TABLE_SIZE 100
int table1[TABLE_SIZE];
#undef TABLE_SIZE
#define TABLE_SIZE 200
int table2[TABLE_SIZE];

// The code above will be translated into:

int table1[100];
int table2[200];
```

### Function Macros

`#define` can also work with parameters to define Function Macros:
```c++
#define getMax(a, b) a > b ? a : b
```
This will not only replace any occurence of getMax followed by 2 arguments by the replacement expression `a > b ? a : b`, but also replace each argument by its identifier, exacely as you would expect if it was a function:
```c++
#include <iostream>
using namespace std;

#define getMax(a, b) ((a)>(b)?(a):(b))

int main()
{
  int x = 5;
  cout << getMax(x, 2) << endl;   // 5
  cout << getMax(7, x) << endl;   // 7
}
```

Function macro definitions accept two special operators `#` and `##` in the replacement sequence. The operator `#` followed by a parameter name, is replaced by a **string literal** that contains the argument passed (as if enclosed between `""`):
```c++
#define str(x) #x
cout << str(test);

// The code above will be translated into:

cout << "test";
```

Operator `##` concatenates 2 arguments, leaving no blank spaces between them:

```c++
#define glue(a, b) a ## b
glue(c, out) << "test";

// The code above will be translated into:
 
cout << "test";
```


## Source File Inclusion: #include

When the preprocessor finds an `#include` directive, it **replaces it by the entire content of the specified header or file**. There are two ways to use `#include`: 
```c++
#include <header>
#include "file"
```
In the first case, `<header>` is used to include headers provided by the implementation, such as the headers that compose the Standard Library (such as `iostream`, `string`...). Whether the headers are actually files or exist in some other forms is implementation-defined, but in any case they shall be properly included with this syntax.

In the second case, `#include` uses quotes to include a file. The file is searched for in an implementation-defined manner, which generally includes the current path. If the file is not found, the compiler interprets the directive as a "header inclusion", just as if the quotes `""` were replaced by `<>`. 


## Conditional Inclusions: #ifdef, #ifndef, #if, #endif, #else, #elif

These directives allow the program to include or exclude part of the code, if a certain condition is met.

`#ifdef` allows a section of code to be compiled only if the macro that is specified as the parameter has been defined, regardless of its value:
```c++
#ifdef TABLE_SIZE
int table[TABLE_SIZE];
#endif
```
`int table[TABLE_SIZE]` is only compiled if `TABLE_SIZE` had been previously defined with `#define`, regardless of its value. If it was not defined, this line will not be included in the program compilation.

`#ifndef` serves for the exact opposite: the code between `#ifndef` and `#endif` directives are only compiled if the specified identifier had not been defined:
```c++
#ifndef TABLE_SIZE
#define TABLE_SIZE 100
#endif
int table[TABLE_SIZE];
```
For this code snippet, if `TABLE_SIZE` had not been defined before, it would be defined to 100. If it had already been defined before this code snippet, it would keep its previous value, since `#define` would not be executed.

`#if`, `#else`, `#elif` (else if) directives serve to specify some condition to be met in order for the section of code they wrap to be compiled. The condition that follows `#if` or `#elif` can only evaluate constant expressions, including macro expressions. For example:
```c++
#if TABLE_SIZE>200
#undef TABLE_SIZE
#define TABLE_SIZE 200
 
#elif TABLE_SIZE<50
#undef TABLE_SIZE
#define TABLE_SIZE 50
 
#else
#undef TABLE_SIZE
#define TABLE_SIZE 100
#endif // the entire structure of #if, #elif and #else chained directives ends with #endif
 
int table[TABLE_SIZE];
```

The behavior of `#ifdef` and `#ifndef` can also be achieved by using the special operators `defined` and `!defined` respectively in any `#if` or `#elif` directive:

```c++
#if defined ARRAY_SIZE
#define TABLE_SIZE ARRAY_SIZE
#elif !defined BUFFER_SIZE
#define TABLE_SIZE 128
#else
#define TABLE_SIZE BUFFER_SIZE
#endif
```

## Line Control: #line

When we compile a program and some error happens during the compiling process, the compiler shows an error message with references to the name of the file where the error happened and a line number, so it is easier to find the code generating the error. The `#line` directive allows us to control both things, the line numbers within the code files as well as the file name that we want that appears when an error takes place. Its format is: 

```c++
line number "filename"
```

Where `number` is the new line number that will be assigned to the next code line. The line numbers of successive lines will be increased one by one from this point on. `"filename"` is an optional parameter that allows to redefine the file name that will be shown. For example, this code will generate an error that will be shown as error in file "assigning variable", line 20:
```c++
#line 20 "assigning variable"
int a?;
```

## Error Directive: #error

This directive aborts the compilation process when it is found, generating a compilation error that can be specified as its parameter:
```c++
#ifndef __cplusplus
#error A C++ compiler is required!
#endif 
```

This example aborts the compilation process if the macro name `__cplusplus` is not defined (this macro name is defined by default in all C++ compilers).

## Pragma (编译注示) Directive: #pragma

This directive is used to specify diverse options to the compiler. These options are specific for the platform and the compiler you use. Consult the manual or the reference of your compiler for more information on the possible parameters that you can define with `#pragma`. If the compiler does not support a specific argument for `#pragma`, it is ignored - no syntax error is generated.

## Predefined Macro Names

The following macro names are always defined (they all begin and end with two underscore characters):

`__LINE__`, `__FILE__`, `__DATE__`, `__TIME__`, `__cplusplus`, `__STDC_HOSTED__`.

The following macros are optionally defined, generally depending on whether a feature is available:

`__STDC__`, `__STDC_VERSION__`, `__STDC_MB_MIGHT_NEQ_WC__`, `__STDC_ISO_10646__`, `__STDCPP_STRICT_POINTER_SAFETY__	`, `__STDCPP_THREADS__`.

```c++
#include <iostream>
using namespace std;

int main()
{
  cout << "This is the line number " << __LINE__;
  cout << " of file " << __FILE__ << ".\n";
  cout << "Its compilation began " << __DATE__;
  cout << " at " << __TIME__ << ".\n";
  cout << "The compiler gives a __cplusplus value of " << __cplusplus;
}
/* 
This is the line number 7 of file /home/jay/stdmacronames.cpp.
Its compilation began Nov  1 2005 at 10:12:29.
The compiler gives a __cplusplus value of 1
*/
```

Particular implementations may define additional constants. For example:

更详细的说明可以参考本文最后的 Reference.



## Reference

* [Preprocessor Directives [cplusplus.com]](http://www.cplusplus.com/doc/tutorial/preprocessor/)

{% include links.html %}